<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Leetcode 151总结 | Openinx Blog</title>
<meta name=keywords content="Algorithm"><meta name=description content='刷了若干天leetcode, 总算弄完了。代码在这里。


Reverse Words in a String
模拟 字符串


Evaluate Reverse Polish Notation
模拟 后缀表达式求值


Max Points on a Line
平面给出N个点，找一个直线，使得经过的点数最多。枚举每个点，以此为原点坐标，求出相对原点坐标，然后计算y/x，用hash表计数求出最大的重复值。O(N^2)


Sort List
QuickSort和MergeSort链表版本. O(NlogN) 值得注意的情况是所有元素都相同时，假设qsort分段从左到右的话，qsort会退化O(N^2).


Insertion Sort List 
插入排序链表实现. O(N^2)


LRU Cache 
LRU-Cache算法。最有复杂度保证每次get,set操作都为O(1). 双向链表+Hash。 用C++10的STL的LIST和MAP的GET，SET复杂度O(logN)


Binary Tree Postorder Traversal 
智商着急，写个栈模拟后序遍历都卡半天。 网上有很简洁的写法。


void postOrderTraversalIterativeTwoStacks(BinaryTree *root) {
  if (!root) return;
  stack<BinaryTree*> s;
  stack<BinaryTree*> output;
  s.push(root);
  while (!s.empty()) {
    BinaryTree *curr = s.top();
    output.push(curr);
    s.pop();
    if (curr->left)
      s.push(curr->left);
    if (curr->right)
      s.push(curr->right);
  }
  while (!output.empty()) {
    cout << output.top()->data << " ";
    output.pop();
  }
}


Binary Tree Preorder Traversal


Reorder List
翻转后半段链表，然后间隔一个拼接。O(N)'><meta name=author content="Zheng Hu"><link rel=canonical href=https://openinx.github.io/posts/2014-07-20-leetcode-151-finished/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://openinx.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://openinx.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://openinx.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://openinx.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://openinx.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://openinx.github.io/posts/2014-07-20-leetcode-151-finished/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-B52L98PJKS"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-B52L98PJKS")}</script><meta property="og:url" content="https://openinx.github.io/posts/2014-07-20-leetcode-151-finished/"><meta property="og:site_name" content="Openinx Blog"><meta property="og:title" content="Leetcode 151总结"><meta property="og:description" content='刷了若干天leetcode, 总算弄完了。代码在这里。
Reverse Words in a String 模拟 字符串
Evaluate Reverse Polish Notation 模拟 后缀表达式求值
Max Points on a Line 平面给出N个点，找一个直线，使得经过的点数最多。枚举每个点，以此为原点坐标，求出相对原点坐标，然后计算y/x，用hash表计数求出最大的重复值。O(N^2)
Sort List QuickSort和MergeSort链表版本. O(NlogN) 值得注意的情况是所有元素都相同时，假设qsort分段从左到右的话，qsort会退化O(N^2).
Insertion Sort List 插入排序链表实现. O(N^2)
LRU Cache LRU-Cache算法。最有复杂度保证每次get,set操作都为O(1). 双向链表+Hash。 用C++10的STL的LIST和MAP的GET，SET复杂度O(logN)
Binary Tree Postorder Traversal 智商着急，写个栈模拟后序遍历都卡半天。 网上有很简洁的写法。
void postOrderTraversalIterativeTwoStacks(BinaryTree *root) { if (!root) return; stack<BinaryTree*> s; stack<BinaryTree*> output; s.push(root); while (!s.empty()) { BinaryTree *curr = s.top(); output.push(curr); s.pop(); if (curr->left) s.push(curr->left); if (curr->right) s.push(curr->right); } while (!output.empty()) { cout << output.top()->data << " "; output.pop(); } } Binary Tree Preorder Traversal
Reorder List 翻转后半段链表，然后间隔一个拼接。O(N)'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-07-20T13:27:08+08:00"><meta property="article:modified_time" content="2014-07-20T13:27:08+08:00"><meta property="article:tag" content="Algorithm"><meta property="og:image" content="https://openinx.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://openinx.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Leetcode 151总结"><meta name=twitter:description content='刷了若干天leetcode, 总算弄完了。代码在这里。


Reverse Words in a String
模拟 字符串


Evaluate Reverse Polish Notation
模拟 后缀表达式求值


Max Points on a Line
平面给出N个点，找一个直线，使得经过的点数最多。枚举每个点，以此为原点坐标，求出相对原点坐标，然后计算y/x，用hash表计数求出最大的重复值。O(N^2)


Sort List
QuickSort和MergeSort链表版本. O(NlogN) 值得注意的情况是所有元素都相同时，假设qsort分段从左到右的话，qsort会退化O(N^2).


Insertion Sort List 
插入排序链表实现. O(N^2)


LRU Cache 
LRU-Cache算法。最有复杂度保证每次get,set操作都为O(1). 双向链表+Hash。 用C++10的STL的LIST和MAP的GET，SET复杂度O(logN)


Binary Tree Postorder Traversal 
智商着急，写个栈模拟后序遍历都卡半天。 网上有很简洁的写法。


void postOrderTraversalIterativeTwoStacks(BinaryTree *root) {
  if (!root) return;
  stack<BinaryTree*> s;
  stack<BinaryTree*> output;
  s.push(root);
  while (!s.empty()) {
    BinaryTree *curr = s.top();
    output.push(curr);
    s.pop();
    if (curr->left)
      s.push(curr->left);
    if (curr->right)
      s.push(curr->right);
  }
  while (!output.empty()) {
    cout << output.top()->data << " ";
    output.pop();
  }
}


Binary Tree Preorder Traversal


Reorder List
翻转后半段链表，然后间隔一个拼接。O(N)'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://openinx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Leetcode 151总结","item":"https://openinx.github.io/posts/2014-07-20-leetcode-151-finished/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Leetcode 151总结","name":"Leetcode 151总结","description":"刷了若干天leetcode, 总算弄完了。代码在这里。\nReverse Words in a String 模拟 字符串\nEvaluate Reverse Polish Notation 模拟 后缀表达式求值\nMax Points on a Line 平面给出N个点，找一个直线，使得经过的点数最多。枚举每个点，以此为原点坐标，求出相对原点坐标，然后计算y/x，用hash表计数求出最大的重复值。O(N^2)\nSort List QuickSort和MergeSort链表版本. O(NlogN) 值得注意的情况是所有元素都相同时，假设qsort分段从左到右的话，qsort会退化O(N^2).\nInsertion Sort List 插入排序链表实现. O(N^2)\nLRU Cache LRU-Cache算法。最有复杂度保证每次get,set操作都为O(1). 双向链表+Hash。 用C++10的STL的LIST和MAP的GET，SET复杂度O(logN)\nBinary Tree Postorder Traversal 智商着急，写个栈模拟后序遍历都卡半天。 网上有很简洁的写法。\nvoid postOrderTraversalIterativeTwoStacks(BinaryTree *root) { if (!root) return; stack\u0026lt;BinaryTree*\u0026gt; s; stack\u0026lt;BinaryTree*\u0026gt; output; s.push(root); while (!s.empty()) { BinaryTree *curr = s.top(); output.push(curr); s.pop(); if (curr-\u0026gt;left) s.push(curr-\u0026gt;left); if (curr-\u0026gt;right) s.push(curr-\u0026gt;right); } while (!output.empty()) { cout \u0026lt;\u0026lt; output.top()-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; \u0026#34;; output.pop(); } } Binary Tree Preorder Traversal\nReorder List 翻转后半段链表，然后间隔一个拼接。O(N)\n","keywords":["Algorithm"],"articleBody":"刷了若干天leetcode, 总算弄完了。代码在这里。\nReverse Words in a String 模拟 字符串\nEvaluate Reverse Polish Notation 模拟 后缀表达式求值\nMax Points on a Line 平面给出N个点，找一个直线，使得经过的点数最多。枚举每个点，以此为原点坐标，求出相对原点坐标，然后计算y/x，用hash表计数求出最大的重复值。O(N^2)\nSort List QuickSort和MergeSort链表版本. O(NlogN) 值得注意的情况是所有元素都相同时，假设qsort分段从左到右的话，qsort会退化O(N^2).\nInsertion Sort List 插入排序链表实现. O(N^2)\nLRU Cache LRU-Cache算法。最有复杂度保证每次get,set操作都为O(1). 双向链表+Hash。 用C++10的STL的LIST和MAP的GET，SET复杂度O(logN)\nBinary Tree Postorder Traversal 智商着急，写个栈模拟后序遍历都卡半天。 网上有很简洁的写法。\nvoid postOrderTraversalIterativeTwoStacks(BinaryTree *root) { if (!root) return; stack\u003cBinaryTree*\u003e s; stack\u003cBinaryTree*\u003e output; s.push(root); while (!s.empty()) { BinaryTree *curr = s.top(); output.push(curr); s.pop(); if (curr-\u003eleft) s.push(curr-\u003eleft); if (curr-\u003eright) s.push(curr-\u003eright); } while (!output.empty()) { cout \u003c\u003c output.top()-\u003edata \u003c\u003c \" \"; output.pop(); } } Binary Tree Preorder Traversal\nReorder List 翻转后半段链表，然后间隔一个拼接。O(N)\nLinked List Cycle II 设一个慢指针， 一个快指针。慢指针每次走一步，快指针每次走两步。假若有环，快指针必定和慢指针在某个环内点重合。然后证明找到重合点之后，再走相同的步数可以找到环的起始点。\nLinked List Cycle 同上。\nWord Break II 给定一个单词集和一个字符串，判断字符串是否可以拆成多个单词，要求每个单词都是单词集里面的。很明显的DP， 问题是要回溯。我写了个递归回溯。复杂度O(N^3).\nWord Break 同上\nCopy List with Random Pointer 这题答案很巧妙。a-\u003eb-\u003ec这样的链表，每个元素后面插入一个前一个元素。a-\u003eA-\u003eb-\u003eB-\u003ec-\u003eC . 然后再设置A，B,C的random指针，最后把A-\u003eB-\u003eC这个链表剥离出来即可。\nBinary Tree Maximum Path Sum 一颗树，每个节点都有一个数。求一条路径，使得路径上各点权值相加最大。动态规划 + 树遍历\nSingle Number II 32位二进制对齐，求N个数各BIT位之和MOD 3形成的二进制转10进制。即答案。\nSingle Number XOR运算满足交换律和结合律。直接XOR各数求和即答案。\nCandy 算法1:每次选择低谷点，然后按照低谷点从小到大排序，一次发各上坡路线的糖果。O(N*logN) 算法2: 左扫上坡路，保存到Array里面，右扫上坡路，与左扫上坡路比较取较大值。O(N) 犯了个傻逼错误：\nint a[3] ; memset(a, 0, sizeof(a)) ; // OK int *a = new int(3) ; memset(a, 0, sizeof(a)) ; // ERROR int *a = new int(3) ; memset(a, 0, sizeof(int) * 3 ) ; // OK Gas Station Clone Graph 图广度优先遍历， 写个深度优先遍历的版本？\nPalindrome Partitioning II DP：将一个字符串切割成若干个回文串，求最小切割次数。O(N^2)\nPalindrome Partitioning DP\nSurrounded Regions 走迷宫问题。有个优化是只要对O在边界上的情况做搜索拓展即可。另外此题卡了DFS的内存，只能用BFS水之。\nSum Root to Leaf Numbers DP + 树遍历\nLongest Consecutive Sequence 为什么直接排序，然后水过去了?\nWord Ladder II BFS 然后按照步数DFS回溯找路径。\nWord Ladder BFS\nValid Palindrome 水题\nBinary Tree Maximum Path Sum DP + 树遍历。 dp[i]表示以i为根节点的子树中，经过i节点的路径的最大和值。 maxsum[i] 表示以i为根节点的子树中，路径最大的和值。 这条路径可能经过i节点，也可能不经过i节点。\ndp[root] = max(root-\u003eval, root-\u003eval + dp[root-\u003eleft], root-\u003eval + dp[root-\u003eright], root-\u003eval + dp[root-\u003eleft] + dp[root-\u003eright]); maxsum[root] = max( maxsum[root-\u003eleft], maxsum[root-\u003eright], dp[root]); Best Time to Buy and Sell Stock III 将序列分割成两段，分别转化成Best Time to Buy and Sell Stock这个问题的最优值。二者求和取最大值即答案。\nBest Time to Buy and Sell Stock II 序列的连续递增增量之和即答案。\nBest Time to Buy and Sell Stock 序列中两数之差最大值即答案。\nTriangle DP + 滚动数组优化空间\nPascal’s Triangle II DP + 滚动数组优化空间。 Pascal数就是组合数，也可以称之为杨辉三角。这个图形推出一个组合公式: C(n,i) = C(n-1,i) + C(n-1,i-1)\nPascal’s Triangle 同上\nPopulating Next Right Pointers in Each Node II 为了达到O(1)的空间复杂度，根据k-1层的Next指针信息遍历，依次将k层的儿子组织成链表，直到到达最底层的叶子层。这个中间没有用到队列，因为next信息已经将k层的节点组织成队列了。\nPopulating Next Right Pointers in Each Node Distinct Subsequences DP + 滚动数组优化空间\ndp[0,j] = 1 ; (0\u003c=j\u003c=strlen(T)) dp[i,0] = 1 ; (0\u003c=i\u003c=strlen(S)) if(s[i-1] == s[j-1]) dp[i,j] = dp[i-1,j-1] + dp[i-1,j] else dp[i,j] = dp[i-1,j] Flatten Binary Tree to Linked List 树遍历 + 链表拼接。 遍历子树得到的链表，应该同时保存链表的head和tail。 否则做左子树和右子树的链表拼接，会消耗O(N)的复杂度，导致算法最后的复杂度为O(N^2).\nPath Sum II 给定一个值SUM, 和一颗树。求树上所有从根到叶子的路径，使得该路径所有节点值之和等于SUM. DFS遍历所有节点，并用vector保存当前路径上的点。\nPath Sum 同上\nMinimum Depth of Binary Tree 求树的最小深度。用栈写一个？\nBalanced Binary Tree 判断一颗树是否平衡(两子树高度相差不超过1)\nConvert Sorted List to Binary Search Tree 链表转成高度平衡的二叉树，直接便利链表找中间点，然后递归构造BST，复杂度O(N*logN). 但有更好的写法, 复杂度O(N)：\nTreeNode* buildTree(ListNode * \u0026list, int start, int end){ if(start \u003e end ) return NULL ; int mid = (start + end ) \u003e\u003e 1; TreeNode* left = buildTree(list, start, mid-1); TreeNode* root = new TreeNode(list-\u003eval); root-\u003eleft = left; list=list-\u003enext; TreeNode *right = buildTree(list, mid+1, end); root-\u003eright = right; return root; } TreeNode *sortedListToBST(ListNode *head) { int n = 0 ; for(ListNode *p = head ; p != NULL ; p=p-\u003enext , ++n); if(n == 0) return NULL; return buildTree(head, 0, n-1); } Convert Sorted Array to Binary Search Tree 将数组转成一颗平衡二叉树。O(N)\nBinary Tree Level Order Traversal II 按照层次依次输出树的各层节点。 BFS\nConstruct Binary Tree from Inorder and Postorder Traversal 给定中序和后序还原二叉树。注意给定前序和后序，是无法还原二叉树的。比如前序为ABCD,后序为BCDA。 我们知道根节点为A,A的儿子们为BCD,但是不能确定左子树和右子树如何划分BCD，所以没法确定树的原型。\nConstruct Binary Tree from Preorder and Inorder Traversal 给定前序和中序，还原二叉树。\nMaximum Depth of Binary Tree 求树的最大深度。 用栈写一个？\nBinary Tree Zigzag Level Order Traversal 按照层次序遍历二叉树。BFS可解。问题假设用两个栈而不用队列怎么解哦？\nBinary Tree Level Order Traversal 二叉树层次便利\nSymmetric Tree 判断二叉树是否左右对称。递归解决\nSame Tree 判断两颗二叉树是否完全相同。类似于上题。\nRecover Binary Search Tree 一颗BST有两个节点的val是颠倒的。怎么找到并纠正？\nValidate Binary Search Tree 如何验证一颗树是否是BST。设计一个int isBST(TreeNode*root, int \u0026maxval, int \u0026minval)接口，表示每次递归解决root这颗子树的问题时，会把该子树所有节点的maxVal和minVal都找出来。这样父亲节点就能够通过比较自己的val和儿子的minval \u0026 maxval来判断是否是BST了。\nInterleaving String DP: O(len(s1) * len(s2)) 滚动数组优化空间到O(min(len(s1) * len(s2)))\ndp[0,0] = 1 dp[0,j] = (s3[j-1] == s2[j-1] \u0026\u0026 dp[0,j-1]) ; when (1\u003c=j\u003c=len2); dp[i,0] = (s3[i-1] == s1[i-1] \u0026\u0026 dp[i-1,j]) ; when (1\u003c=i\u003c=len1); dp[i,j] = (s3[i+j-1] == s1[i-1] \u0026\u0026 dp[i-1][j]) | (s3[i+j-1] == s2[j-1] \u0026\u0026 dp[i][j-1]) ; when (1\u003c=i\u003c=len1 \u0026\u0026 1\u003c=j\u003c=len2 ) Unique Binary Search Trees II 给定N，求出所有节点号为1..N的BST的树。DFS递归求解。\nUnique Binary Search Trees 求N个节点的BST总数。经典的Catalan Number C(2n,n)/(n+1). 递推式为\nh[0] = 1 h[1] = 1 h[n] = h[0]*h[n-1] + h[1]*[n-2] + ... + h[n-1] * h[0] ; Restore IP Addresses 暴力水过, O(12^3)\nReverse Linked List II 逆转链表的一段\nSubsets II DFS\nScramble String\nPartition List 链表实现QuickSort的select函数。\nLargest Rectangle in Histogram 求给定序列组成的柱形图中最大长方形面积。(单调栈 OR 并查集)\n单调栈实现:\nint largestRectangleArea(vector\u003cint\u003e \u0026height) { stack\u003cint\u003e s ; height.push_back(0); int i = 0, maxArea = 0 ; while( i \u003c height.size() ){ if(s.empty() || height[s.top()] \u003c= height[i]){ s.push(i++); }else{ int t = s.top(); s.pop(); maxArea = max(maxArea, height[t] * (s.empty() ? i: i-s.top()-1)); } } return maxArea; } 并查集实现：\nfor(i = 1 ; i\u003c=n; ++i) scanf(\"%d\",\u0026h[i]); for(i = 1 ; i\u003c=n; ++i) r[i] = l[i] = i; h[0] = h[n +1] = -1; for(i = 1 ; i\u003c=n; ++i) while( h[i] \u003c= h[ l[i] - 1 ] ) l[i] = l[ l[i] - 1 ]; for(i = n ; i\u003e= 1 ; --i) while( h[i] \u003c= h[ r[i] + 1 ] ) r[i] =r[ r[i] + 1 ]; __int64 ans = 0; for( i = 1 ; i\u003c=n; ++i) ans = max( ans , (__int64)(r[i] - l[i] + 1 ) * (__int64)h[i] ); 3Sum 给定一个序列，求有多少个三元组使得(a+b+c=0). 对Array排序，枚举c，然后再一个有序序列中寻找两个数之和是否等于C。有两种方法： 将a放在一个hash表里面，然后查找C-a 是否在hash表内。 设置一个左指针lptr，一个右指针rptr。 二者之和大于-C时， rptr左移。 小于-C时, lptr右移。比较trick的是对于序列-2 0 1 1 2 2这种情况，碰到第一个1时，-2 0 1不能组成三元组使得等于0，-2 0 1 1可以组成三元组等于0。所以碰到连续的相同的元素，只需要考虑连续数的最后一个数即可。 3Sum Closest 类似3Sum的思路。可以证明：当lptr + rptr \u003e C时, 不可能通过lptr左移使得abs(lptr+rptr-C)变小, 只能是rptr右移使之变小 。所以实现方法和3Sum一样。\nInsert Interval\nWildcard Matching KMP + 贪心 假设的个数为K, 复杂度O(KN) 其实写个_看毛片算法_解这个问题真的是坑无数。比如最后一个’hi’和’?‘这种情况，‘’不能贪婪匹配’hi’。 归纳起来，最后一个’‘是不能贪婪的，只要求’‘之后的字串能严格和主串的最后一段匹配即可。关于这个问题的更详细的各种解法，可参考一个老外数十年的辛勤劳作。\nPow(x, n)二分求P^n值。值得注意的是，当int n = -2147483648 时，调用函数abs(n) = 2147483648时，会导致INT溢出。 这是调用int类型的abs函数道不尽说不完的坑啊。\nContainer With Most Water DP ： 关键在于慧眼发现这样一个性质： 假设3 5 2 4 3 5这个序列, 两个端点，3和5。 对3来讲，最优解肯定是5，3不可能和其他的某个数达到最优解。所以3就排除掉了， 左端点右移，转化成一个较小规模的子问题了。 复杂度O(N)\nMerge k Sorted Lists两种方法： 两两合并复杂度为O(KN), 假设K为要合并的链表的个数，N为K个链表的所有元素之和;用一个元素个数为K的堆维护K个链表。复杂度为O(NlogK)。\n纠结了好一会儿堆的cmp重载。C++默认的堆是最大堆。\nclass classcmp{ public: bool operator() (const ListNode* a, const ListNode* b)const{ return a-\u003eval \u003e b-\u003eval ; } }; priority_queue\u003cListNode*, vector\u003cListNode*\u003e, classcmp\u003e que ; Combination Sum DFS\nCombination Sum II DFS: 对于1 1 1 2 5 6 7 10这种序列，防止出现重复的1 1 2这个序列很重要。其实只要保证选择的1全部都在1 1 1序列的最前端就可以了。当DFS到depth这个深度时，走没有选择Element[depth]这个元素的分支时，后面所有与Element[depth]相等的元素，就都不考虑放到解之中了。 走选择了Element[depth]这条分支时，按照正常递归下去就OK了。 这样可以保证无重复解。\nMultiply Strings 大数乘法\nPermutations 生成序列[1,2,3..,n]的全排列。\npermutations-ii 生成有重复元素的的全排列，要求不能输出重复的排列。 我用的方法是： 对每个数都用了一个cnt计数器，当递归到当前深度时，试探所有cnt值大于1的数，然后将当前深度的值填为该数。\nN-Queens N皇后问题，求所有解。\nN-Queens II N皇后问题， 求解数。尝试几种写法：DFS; 迭代；位运算。 位运算代码最少，如下（答案调用dfs(0,0,0,n,sum)，sum值即答案）：\n#define LOWBIT(x) ((x)\u0026(-x)) void dfs(int row, int ld, int rd, int n, int \u0026sum){ int M = (1\u003c\u003cn)-1, pos, p; if(row == M) { ++ sum; return;} pos = ((row|ld|rd) \u0026 M) ^ M; while(pos){ p = LOWBIT(pos); dfs(row|p, (ld|p)\u003c\u003c1, (rd|p)\u003e\u003e1, n, sum); pos -= pos \u0026 p; } } Add Binary 水题一枚。 调程序一个BUG很不好找： (temp \u0026 1) + '0' // a = temp \u0026 1 ; b = a + '0' ; temp \u0026 1 + '0' // a = 1 + '0' ; b = temp \u0026 1 ; Sort Colors 智力题。看下图这种状态，有r,w,b三个指针。[0,r)的都是0，[r,w)都是1, [b,+oo)都是2。 现在考虑w指针所在的数，分三种情况： (0) w指的数为0,交换w和r所在的数，r和w指针同时右移。 (1) w指的数为1,w右移; (2) w指的数为2,b左移，交换w和b指针所在的数;\nvoid sortColors(int A[], int n) { for (int r = 0, w = 0, b = n; w \u003c b; ) if (A[w] == 0) swap(A[r++], A[w++]); else if (A[w] == 2) swap(A[--b], A[w]); else w++; } 看到该题背景顿时吓傻\n# start 0001111********2222 ^ ^ ^ r w b # case.0 00001111*******2222 ^ ^ ^ r w b # case.1 00011111*******2222 ^ ^ ^ r w b # case.2 0001111*******22222 ^ ^ ^ r w b First Missing Positive 智力题，找出一个无序序列中第一个缺失的正整数。要求时间O(N)，空间O(1). 其实只要将每个在1～N之前的整数，把i这个数值存放到A[i]这里存放。然后遍历即可。代码如下,复杂度分析：while循环每次swap都会把A[i]这个数放到A[i]-1这个Index对应的位置存放，最多有N个数，所以for循环内所有while进行的swap操作之和不超过N. 摊分下来每个for操作都swap一次。总的复杂度为O(N). int firstMissingPositive(int A[], int n) { for(int i = 0 ; i \u003c n ; ++ i) while(A[i] \u003e 0 \u0026\u0026 A[i] \u003c= n \u0026\u0026 A[A[i]-1] != A[i]) swap(A[A[i]-1], A[i]); for(int i = 0 ; i \u003c n ; ++ i) if(A[i] != i + 1) return i + 1; return n + 1; } Anagrams anagrams这个单词真是个费解的单词。指的是对应字符个数相等的两个单词，称为anagrams. 例如aaaab和baaaa,aaaba都是anagrams。 每个单词字符排个序，最小字典序唯一。直接hash表判重即可。复杂度O(NMlogM), 单词最大长度为M， 共有N个单词。\nEdit Distance 求两个字符串的最小编辑距离，从S串到T串，有三种操作： insert; delete; replace. dp[i,j]表示s[1..i]到t[1..j]的最小编辑距离:\ndp[0,0] = 0 ; dp[0,j] = j (1\u003c=j\u003c=len(t)) dp[i,0] = i (1\u003c=i\u003c=len(s)) dp[i,j] = min(dp[i-1,j] + 1, dp[i,j-1] + 1, dp[i-1,j-1] + 1) // delete, insert, replace if(s[i] == t[j]) dp[i,j] = min(dp[i,j], dp[i-1,j-1]); Trapping Rain Water智力题。关键考虑每个i对答案的贡献值求和。能用一次遍历并且用O(1)的空间计算出答案吗？ 这里还有个悲剧的故事\nSet Matrix Zeroes matrix[0,i]和matrix[i,0]保存maxtrix[i,j]的0状态,另设两个遍历row,col记录matrix[0,0..n-1]和matrix[0..n-1,0]是否为0.即可。\nMedian of Two Sorted Arrays两个有序序列A[0..M-1]和B[0..N-1]找第k小的数问题。假设A[k/2-1]","wordCount":"1491","inLanguage":"en","image":"https://openinx.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2014-07-20T13:27:08+08:00","dateModified":"2014-07-20T13:27:08+08:00","author":{"@type":"Person","name":"Zheng Hu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://openinx.github.io/posts/2014-07-20-leetcode-151-finished/"},"publisher":{"@type":"Organization","name":"Openinx Blog","logo":{"@type":"ImageObject","url":"https://openinx.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://openinx.github.io/ accesskey=h title="openinx (Alt + H)">openinx</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://openinx.github.io/about/ title=About><span>About</span></a></li><li><a href=https://openinx.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://openinx.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://openinx.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://openinx.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Leetcode 151总结</h1><div class=post-meta><span title='2014-07-20 13:27:08 +0800 CST'>July 20, 2014</span>&nbsp;·&nbsp;Zheng Hu</div></header><div class=post-content><p>刷了若干天leetcode, 总算弄完了。代码在<a href=https://github.com/openinx/algorithm-solution/tree/master/leetcode>这里</a>。</p><ul><li><p><a href=https://oj.leetcode.com/problems/reverse-words-in-a-string/>Reverse Words in a String</a>
模拟 字符串</p></li><li><p><a href=https://oj.leetcode.com/problems/evaluate-reverse-polish-notation/>Evaluate Reverse Polish Notation</a>
模拟 后缀表达式求值</p></li><li><p><a href=https://oj.leetcode.com/problems/max-points-on-a-line/>Max Points on a Line</a>
平面给出N个点，找一个直线，使得经过的点数最多。枚举每个点，以此为原点坐标，求出相对原点坐标，然后计算y/x，用hash表计数求出最大的重复值。O(N^2)</p></li><li><p><a href=https://oj.leetcode.com/problems/sort-list/>Sort List</a>
QuickSort和MergeSort链表版本. O(NlogN) 值得注意的情况是所有元素都相同时，假设qsort分段从左到右的话，qsort会退化O(N^2).</p></li><li><p><a href=https://oj.leetcode.com/problems/insertion-sort-list/>Insertion Sort List </a>插入排序链表实现. O(N^2)</p></li><li><p><a href=https://oj.leetcode.com/problems/lru-cache/>LRU Cache </a>LRU-Cache算法。最有复杂度保证每次get,set操作都为O(1). 双向链表+Hash。 用C++10的STL的LIST和MAP的GET，SET复杂度O(logN)</p></li><li><p><a href=https://oj.leetcode.com/problems/binary-tree-postorder-traversal/>Binary Tree Postorder Traversal </a>智商着急，写个栈模拟后序遍历都卡半天。 网上有很简洁的写法。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>postOrderTraversalIterativeTwoStacks</span><span class=p>(</span><span class=n>BinaryTree</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>root</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack</span><span class=o>&lt;</span><span class=n>BinaryTree</span><span class=o>*&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>stack</span><span class=o>&lt;</span><span class=n>BinaryTree</span><span class=o>*&gt;</span> <span class=n>output</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>s</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>s</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BinaryTree</span> <span class=o>*</span><span class=n>curr</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>curr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>curr</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>curr</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>curr</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>s</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>curr</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>output</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>output</span><span class=p>.</span><span class=n>top</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>output</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/binary-tree-preorder-traversal/>Binary Tree Preorder Traversal</a></p></li><li><p><a href=https://oj.leetcode.com/problems/reorder-list/>Reorder List</a>
翻转后半段链表，然后间隔一个拼接。O(N)</p></li><li><p><a href=https://oj.leetcode.com/problems/linked-list-cycle-ii/>Linked List Cycle II </a>设一个慢指针， 一个快指针。慢指针每次走一步，快指针每次走两步。假若有环，快指针必定和慢指针在某个环内点重合。然后证明找到重合点之后，再走相同的步数可以找到环的起始点。</p></li><li><p><a href=https://oj.leetcode.com/problems/linked-list-cycle/>Linked List Cycle</a>
同上。</p></li><li><p><a href=https://oj.leetcode.com/problems/word-break-ii/>Word Break II </a>给定一个单词集和一个字符串，判断字符串是否可以拆成多个单词，要求每个单词都是单词集里面的。很明显的DP， 问题是要回溯。我写了个递归回溯。复杂度O(N^3).</p></li><li><p><a href=https://oj.leetcode.com/problems/word-break/>Word Break</a>
同上</p></li><li><p><a href=https://oj.leetcode.com/problems/copy-list-with-random-pointer/>Copy List with Random Pointer</a>
这题答案很巧妙。a->b->c这样的链表，每个元素后面插入一个前一个元素。a->A->b->B->c->C . 然后再设置A，B,C的random指针，最后把A->B->C这个链表剥离出来即可。</p></li><li><p><a href=https://oj.leetcode.com/problems/binary-tree-maximum-path-sum/>Binary Tree Maximum Path Sum</a>
一颗树，每个节点都有一个数。求一条路径，使得路径上各点权值相加最大。动态规划 + 树遍历</p></li><li><p><a href=https://oj.leetcode.com/problems/single-number-ii/>Single Number II</a>
32位二进制对齐，求N个数各BIT位之和MOD 3形成的二进制转10进制。即答案。</p></li><li><p><a href=https://oj.leetcode.com/problems/single-number/>Single Number</a>
XOR运算满足交换律和结合律。直接XOR各数求和即答案。</p></li><li><p><a href=https://oj.leetcode.com/problems/candy/>Candy</a>
算法1:每次选择低谷点，然后按照低谷点从小到大排序，一次发各上坡路线的糖果。O(N*logN)
算法2: 左扫上坡路，保存到Array里面，右扫上坡路，与左扫上坡路比较取较大值。O(N)
犯了个傻逼错误：</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=p>;</span> <span class=n>memset</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>a</span><span class=p>))</span> <span class=p>;</span> <span class=c1>// OK 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=p>;</span> <span class=n>memset</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>a</span><span class=p>))</span> <span class=p>;</span> <span class=c1>// ERROR 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=p>;</span> <span class=n>memset</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span> <span class=p>)</span> <span class=p>;</span> <span class=c1>// OK 
</span></span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/gas-station/>Gas Station</a></p></li><li><p><a href=https://oj.leetcode.com/problems/clone-graph/>Clone Graph</a>
图广度优先遍历， 写个深度优先遍历的版本？</p></li><li><p><a href=https://oj.leetcode.com/problems/palindrome-partitioning-ii/>Palindrome Partitioning II</a>
DP：将一个字符串切割成若干个回文串，求最小切割次数。O(N^2)</p></li><li><p><a href=https://oj.leetcode.com/problems/palindrome-partitioning/>Palindrome Partitioning </a>DP</p></li><li><p><a href=https://oj.leetcode.com/problems/surrounded-regions/>Surrounded Regions </a>走迷宫问题。有个优化是只要对O在边界上的情况做搜索拓展即可。另外此题卡了DFS的内存，只能用BFS水之。</p></li><li><p><a href=https://oj.leetcode.com/problems/sum-root-to-leaf-numbers/>Sum Root to Leaf Numbers </a>DP + 树遍历</p></li><li><p><a href=https://oj.leetcode.com/problems/longest-consecutive-sequence/>Longest Consecutive Sequence </a>为什么直接排序，然后水过去了?</p></li><li><p><a href=https://oj.leetcode.com/problems/word-ladder-ii/>Word Ladder II</a>
BFS 然后按照步数DFS回溯找路径。</p></li><li><p><a href=https://oj.leetcode.com/problems/word-ladder/>Word Ladder </a>BFS</p></li><li><p><a href=https://oj.leetcode.com/problems/valid-palindrome/>Valid Palindrome</a>
水题</p></li><li><p><a href=https://oj.leetcode.com/problems/binary-tree-maximum-path-sum/>Binary Tree Maximum Path Sum</a>
DP + 树遍历。
dp[i]表示以i为根节点的子树中，经过i节点的路径的最大和值。
maxsum[i] 表示以i为根节点的子树中，路径最大的和值。 这条路径可能经过i节点，也可能不经过i节点。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=n>root</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>],</span>
</span></span><span class=line><span class=cl>               <span class=n>root</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>],</span>
</span></span><span class=line><span class=cl>               <span class=n>root</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=n>maxsum</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span> <span class=n>maxsum</span><span class=p>[</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>],</span> <span class=n>maxsum</span><span class=p>[</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>root</span><span class=p>]);</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/>Best Time to Buy and Sell Stock III</a>
将序列分割成两段，分别转化成<a href=https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/>Best Time to Buy and Sell Stock</a>这个问题的最优值。二者求和取最大值即答案。</p></li><li><p><a href=https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/>Best Time to Buy and Sell Stock II</a>
序列的连续递增增量之和即答案。</p></li><li><p><a href=https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/>Best Time to Buy and Sell Stock</a>
序列中两数之差最大值即答案。</p></li><li><p><a href=https://oj.leetcode.com/problems/triangle/>Triangle</a>
DP + 滚动数组优化空间</p></li><li><p><a href=https://oj.leetcode.com/problems/pascals-triangle-ii/>Pascal&rsquo;s Triangle II</a>
DP + 滚动数组优化空间。 Pascal数就是组合数，也可以称之为杨辉三角。这个图形推出一个组合公式: C(n,i) = C(n-1,i) + C(n-1,i-1)</p></li><li><p><a href=https://oj.leetcode.com/problems/pascals-triangle/>Pascal&rsquo;s Triangle</a>
同上</p></li><li><p><a href=https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/>Populating Next Right Pointers in Each Node II </a>为了达到O(1)的空间复杂度，根据k-1层的Next指针信息遍历，依次将k层的儿子组织成链表，直到到达最底层的叶子层。这个中间没有用到队列，因为next信息已经将k层的节点组织成队列了。</p></li><li><p><a href=https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node/>Populating Next Right Pointers in Each Node</a></p></li><li><p><a href=https://oj.leetcode.com/problems/distinct-subsequences/>Distinct Subsequences</a>
DP + 滚动数组优化空间</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>;</span> <span class=p>(</span><span class=mi>0</span><span class=o>&lt;=</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>strlen</span><span class=p>(</span><span class=n>T</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>;</span> <span class=p>(</span><span class=mi>0</span><span class=o>&lt;=</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>strlen</span><span class=p>(</span><span class=n>S</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>]</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/>Flatten Binary Tree to Linked List </a>树遍历 + 链表拼接。 遍历子树得到的链表，应该同时保存链表的head和tail。 否则做左子树和右子树的链表拼接，会消耗O(N)的复杂度，导致算法最后的复杂度为O(N^2).</p></li><li><p><a href=https://oj.leetcode.com/problems/path-sum-ii/>Path Sum II</a>
给定一个值SUM, 和一颗树。求树上所有从根到叶子的路径，使得该路径所有节点值之和等于SUM. DFS遍历所有节点，并用vector保存当前路径上的点。</p></li><li><p><a href=https://oj.leetcode.com/problems/path-sum/>Path Sum</a>
同上</p></li><li><p><a href=https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/>Minimum Depth of Binary Tree</a>
求树的最小深度。用栈写一个？</p></li><li><p><a href=https://oj.leetcode.com/problems/balanced-binary-tree/>Balanced Binary Tree</a>
判断一颗树是否平衡(两子树高度相差不超过1)</p></li><li><p><a href=https://oj.leetcode.com/problems/convert-sorted-list-to-binary-search-tree/>Convert Sorted List to Binary Search Tree </a>链表转成高度平衡的二叉树，直接便利链表找中间点，然后递归构造BST，复杂度O(N*logN). 但有更好的写法, 复杂度O(N)：</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>TreeNode</span><span class=o>*</span> <span class=nf>buildTree</span><span class=p>(</span><span class=n>ListNode</span> <span class=o>*</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>start</span> <span class=o>&gt;</span> <span class=n>end</span> <span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>mid</span> <span class=o>=</span>  <span class=p>(</span><span class=n>start</span> <span class=o>+</span> <span class=n>end</span> <span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>TreeNode</span><span class=o>*</span> <span class=n>left</span> <span class=o>=</span> <span class=n>buildTree</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>mid</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>TreeNode</span><span class=o>*</span> <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeNode</span><span class=p>(</span><span class=n>list</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span> <span class=o>=</span> <span class=n>left</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>list</span><span class=o>=</span><span class=n>list</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>TreeNode</span> <span class=o>*</span><span class=n>right</span> <span class=o>=</span> <span class=n>buildTree</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span> <span class=o>=</span> <span class=n>right</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>TreeNode</span> <span class=o>*</span><span class=nf>sortedListToBST</span><span class=p>(</span><span class=n>ListNode</span> <span class=o>*</span><span class=n>head</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>ListNode</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>head</span> <span class=p>;</span> <span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=p>;</span> <span class=n>p</span><span class=o>=</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>next</span> <span class=p>,</span> <span class=o>++</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   	<span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>buildTree</span><span class=p>(</span><span class=n>head</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/convert-sorted-array-to-binary-search-tree/>Convert Sorted Array to Binary Search Tree</a>
将数组转成一颗平衡二叉树。O(N)</p></li><li><p><a href=https://oj.leetcode.com/problems/binary-tree-level-order-traversal-ii/>Binary Tree Level Order Traversal II </a>按照层次依次输出树的各层节点。 BFS</p></li><li><p><a href=https://oj.leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>Construct Binary Tree from Inorder and Postorder Traversal</a>
给定中序和后序还原二叉树。注意给定前序和后序，是无法还原二叉树的。比如前序为ABCD,后序为BCDA。 我们知道根节点为A,A的儿子们为BCD,但是不能确定左子树和右子树如何划分BCD，所以没法确定树的原型。</p></li><li><p><a href=https://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>Construct Binary Tree from Preorder and Inorder Traversal</a>
给定前序和中序，还原二叉树。</p></li><li><p><a href=https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/>Maximum Depth of Binary Tree</a>
求树的最大深度。 用栈写一个？</p></li><li><p><a href=https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/>Binary Tree Zigzag Level Order Traversal </a>按照层次序遍历二叉树。BFS可解。问题假设用两个栈而不用队列怎么解哦？</p></li><li><p><a href=https://oj.leetcode.com/problems/binary-tree-level-order-traversal/>Binary Tree Level Order Traversal</a>
二叉树层次便利</p></li><li><p><a href=https://oj.leetcode.com/problems/symmetric-tree/>Symmetric Tree</a>
判断二叉树是否左右对称。递归解决</p></li><li><p><a href=https://oj.leetcode.com/problems/same-tree/>Same Tree</a>
判断两颗二叉树是否完全相同。类似于上题。</p></li><li><p><a href=https://oj.leetcode.com/problems/recover-binary-search-tree/>Recover Binary Search Tree</a>
一颗BST有两个节点的val是颠倒的。怎么找到并纠正？</p></li><li><p><a href=https://oj.leetcode.com/problems/validate-binary-search-tree/>Validate Binary Search Tree</a>
如何验证一颗树是否是BST。设计一个<code>int isBST(TreeNode*root, int &amp;maxval, int &amp;minval)</code>接口，表示每次递归解决root这颗子树的问题时，会把该子树所有节点的maxVal和minVal都找出来。这样父亲节点就能够通过比较自己的val和儿子的minval & maxval来判断是否是BST了。</p></li><li><p><a href=https://oj.leetcode.com/problems/interleaving-string/>Interleaving String</a>
DP: O(len(s1) * len(s2)) 滚动数组优化空间到O(min(len(s1) * len(s2)))</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> 
</span></span><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>s3</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=p>;</span> <span class=n>when</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;=</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>len2</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>s3</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>])</span> <span class=p>;</span> <span class=n>when</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;=</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>len1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>s3</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s1</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>])</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>s3</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s2</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=p>;</span> 
</span></span><span class=line><span class=cl>          <span class=n>when</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;=</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>len1</span> <span class=o>&amp;&amp;</span> <span class=mi>1</span><span class=o>&lt;=</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>len2</span> <span class=p>)</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/unique-binary-search-trees-ii/>Unique Binary Search Trees II</a>
给定N，求出所有节点号为1..N的BST的树。DFS递归求解。</p></li><li><p><a href=https://oj.leetcode.com/problems/unique-binary-search-trees/>Unique Binary Search Trees </a>求N个节点的BST总数。经典的<a href=http://en.wikipedia.org/wiki/Catalan_number>Catalan Number</a> C(2n,n)/(n+1). 递推式为</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>h</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span> 
</span></span><span class=line><span class=cl><span class=n>h</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=n>h</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>h</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>*</span><span class=n>h</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>h</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=p>...</span> <span class=o>+</span> <span class=n>h</span><span class=p>[</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>h</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>;</span> 
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/restore-ip-addresses/>Restore IP Addresses</a>
暴力水过, O(12^3)</p></li><li><p><a href=https://oj.leetcode.com/problems/reverse-linked-list-ii/>Reverse Linked List II</a>
逆转链表的一段</p></li><li><p><a href=https://oj.leetcode.com/problems/subsets-ii/>Subsets II </a>DFS</p></li><li><p><a href=https://oj.leetcode.com/problems/scramble-string/>Scramble String</a></p></li><li><p><a href=https://oj.leetcode.com/problems/partition-list/>Partition List</a>
链表实现QuickSort的select函数。</p></li><li><p><a href=https://oj.leetcode.com/problems/largest-rectangle-in-histogram/>Largest Rectangle in Histogram </a>求给定序列组成的柱形图中最大长方形面积。(单调栈 OR 并查集)</p></li></ul><p>单调栈实现:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>largestRectangleArea</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>height</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>s</span> <span class=p>;</span> 
</span></span><span class=line><span class=cl>	<span class=n>height</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>maxArea</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>(</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>height</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>||</span> <span class=n>height</span><span class=p>[</span><span class=n>s</span><span class=p>.</span><span class=n>top</span><span class=p>()]</span> <span class=o>&lt;=</span> <span class=n>height</span><span class=p>[</span><span class=n>i</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>			<span class=n>s</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>i</span><span class=o>++</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>top</span><span class=p>();</span> <span class=n>s</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>			<span class=n>maxArea</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>maxArea</span><span class=p>,</span> <span class=n>height</span><span class=p>[</span><span class=n>t</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>?</span> <span class=nl>i</span><span class=p>:</span> <span class=n>i</span><span class=o>-</span><span class=n>s</span><span class=p>.</span><span class=n>top</span><span class=p>()</span><span class=o>-</span><span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>maxArea</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>并查集实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=n>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span><span class=o>&amp;</span><span class=n>h</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>  <span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>h</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>h</span><span class=p>[</span><span class=n>n</span> <span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span> <span class=n>h</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>h</span><span class=p>[</span> <span class=n>l</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span> <span class=p>]</span> <span class=p>)</span> <span class=n>l</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>l</span><span class=p>[</span> <span class=n>l</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span> <span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>n</span> <span class=p>;</span> <span class=n>i</span><span class=o>&gt;=</span> <span class=mi>1</span> <span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span> <span class=n>h</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>h</span><span class=p>[</span> <span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>]</span> <span class=p>)</span>  <span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span><span class=n>r</span><span class=p>[</span> <span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kr>__int64</span> <span class=n>ans</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span> <span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=n>ans</span>  <span class=o>=</span> <span class=n>max</span><span class=p>(</span> <span class=n>ans</span> <span class=p>,</span> <span class=p>(</span><span class=kr>__int64</span><span class=p>)(</span><span class=n>r</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>l</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=kr>__int64</span><span class=p>)</span><span class=n>h</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span></code></pre></div><ul><li><a href=https://oj.leetcode.com/problems/3sum/>3Sum</a>
给定一个序列，求有多少个三元组使得(a+b+c=0). 对Array排序，枚举c，然后再一个有序序列中寻找两个数之和是否等于C。有两种方法：</li></ul><ol><li>将a放在一个hash表里面，然后查找C-a 是否在hash表内。</li><li>设置一个左指针lptr，一个右指针rptr。 二者之和大于-C时， rptr左移。 小于-C时, lptr右移。比较trick的是对于序列<code>-2 0 1 1 2 2</code>这种情况，碰到第一个1时，<code>-2 0 1</code>不能组成三元组使得等于0，<code>-2 0 1 1</code>可以组成三元组等于0。所以碰到连续的相同的元素，只需要考虑连续数的最后一个数即可。</li></ol><ul><li><p><a href=https://oj.leetcode.com/problems/3sum-closest/>3Sum Closest</a>
类似<a href=https://oj.leetcode.com/problems/3sum/>3Sum</a>的思路。可以证明：当<code>lptr + rptr > C</code>时, 不可能通过lptr左移使得abs(lptr+rptr-C)变小, 只能是rptr右移使之变小 。所以实现方法和<a href=https://oj.leetcode.com/problems/3sum/>3Sum</a>一样。</p></li><li><p><a href=https://oj.leetcode.com/problems/insert-interval/>Insert Interval</a></p></li><li><p><a href=https://oj.leetcode.com/problems/wildcard-matching/>Wildcard Matching</a>
KMP + 贪心 假设<em>的个数为K, 复杂度O(K</em>N) 其实写个_看毛片算法_解这个问题真的是坑无数。比如最后一个&rsquo;hi&rsquo;和&rsquo;<em>?&lsquo;这种情况，‘</em>’不能贪婪匹配&rsquo;hi&rsquo;。 归纳起来，最后一个&rsquo;<em>&lsquo;是不能贪婪的，只要求&rsquo;</em>&lsquo;之后的字串能严格和主串的最后一段匹配即可。关于这个问题的更详细的各种解法，可参考<a href=http://xoomer.virgilio.it/acantato/dev/wildcard/wildmatch.html>一个老外数十年的辛勤劳作</a>。</p></li><li><p><a href=https://oj.leetcode.com/problems/powx-n/>Pow(x, n)</a>二分求<code>P^n</code>值。值得注意的是，当int n = -2147483648 时，调用函数abs(n) = 2147483648时，会导致INT溢出。 <em>这是调用int类型的abs函数道不尽说不完的坑啊。</em></p></li><li><p><a href=https://oj.leetcode.com/problems/container-with-most-water/>Container With Most Water</a>
DP ： 关键在于慧眼发现这样一个性质： 假设<code>3 5 2 4 3 5</code>这个序列, 两个端点，3和5。 对3来讲，最优解肯定是5，3不可能和其他的某个数达到最优解。所以3就排除掉了， 左端点右移，转化成一个较小规模的子问题了。 复杂度O(N)</p></li><li><p><a href=https://oj.leetcode.com/problems/merge-k-sorted-lists/>Merge k Sorted Lists</a>两种方法： 两两合并复杂度为O(K<em>N), 假设K为要合并的链表的个数，N为K个链表的所有元素之和;用一个元素个数为K的堆维护K个链表。复杂度为O(N</em>logK)。</p></li></ul><p>纠结了好一会儿堆的cmp重载。C++默认的堆是最大堆。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>classcmp</span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=k>operator</span><span class=p>()</span> <span class=p>(</span><span class=k>const</span> <span class=n>ListNode</span><span class=o>*</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>ListNode</span><span class=o>*</span> <span class=n>b</span><span class=p>)</span><span class=k>const</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>&gt;</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>val</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>priority_queue</span><span class=o>&lt;</span><span class=n>ListNode</span><span class=o>*</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>ListNode</span><span class=o>*&gt;</span><span class=p>,</span> <span class=n>classcmp</span><span class=o>&gt;</span> <span class=n>que</span> <span class=p>;</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/combination-sum/>Combination Sum</a>
DFS</p></li><li><p><a href=https://oj.leetcode.com/problems/combination-sum-ii/>Combination Sum II</a>
DFS: 对于<code>1 1 1 2 5 6 7 10</code>这种序列，防止出现重复的<code>1 1 2</code>这个序列很重要。其实只要保证选择的<code>1</code>全部都在<code>1 1 1</code>序列的最前端就可以了。当DFS到depth这个深度时，走没有选择<code>Element[depth]</code>这个元素的分支时，后面所有与<code>Element[depth]</code>相等的元素，就都不考虑放到解之中了。 走选择了<code>Element[depth]</code>这条分支时，按照正常递归下去就OK了。 这样可以保证无重复解。</p></li><li><p><a href=https://oj.leetcode.com/problems/multiply-strings/>Multiply Strings </a>大数乘法</p></li><li><p><a href=https://oj.leetcode.com/problems/permutations/>Permutations </a>生成序列[1,2,3..,n]的全排列。</p></li><li><p><a href=https://oj.leetcode.com/problems/permutations-ii/>permutations-ii</a> 生成有重复元素的的全排列，要求不能输出重复的排列。 我用的方法是： 对每个数都用了一个cnt计数器，当递归到当前深度时，试探所有cnt值大于1的数，然后将当前深度的值填为该数。</p></li><li><p><a href=https://oj.leetcode.com/problems/n-queens/>N-Queens</a> N皇后问题，求所有解。</p></li><li><p><a href=https://oj.leetcode.com/problems/n-queens-ii/>N-Queens II </a>N皇后问题， 求解数。尝试几种写法：DFS; 迭代；位运算。 位运算代码最少，如下（答案调用dfs(0,0,0,n,sum)，sum值即答案）：</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define LOWBIT(x) ((x)&amp;(-x))
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>dfs</span><span class=p>(</span><span class=kt>int</span> <span class=n>row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>ld</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=n>sum</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>M</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=n>n</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>pos</span><span class=p>,</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>row</span> <span class=o>==</span> <span class=n>M</span><span class=p>)</span> <span class=p>{</span>  <span class=o>++</span> <span class=n>sum</span><span class=p>;</span> <span class=k>return</span><span class=p>;}</span> 
</span></span><span class=line><span class=cl>    <span class=n>pos</span> <span class=o>=</span> <span class=p>((</span><span class=n>row</span><span class=o>|</span><span class=n>ld</span><span class=o>|</span><span class=n>rd</span><span class=p>)</span> <span class=o>&amp;</span> <span class=n>M</span><span class=p>)</span> <span class=o>^</span> <span class=n>M</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>pos</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>LOWBIT</span><span class=p>(</span><span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>row</span><span class=o>|</span><span class=n>p</span><span class=p>,</span> <span class=p>(</span><span class=n>ld</span><span class=o>|</span><span class=n>p</span><span class=p>)</span><span class=o>&lt;&lt;</span><span class=mi>1</span><span class=p>,</span> <span class=p>(</span><span class=n>rd</span><span class=o>|</span><span class=n>p</span><span class=p>)</span><span class=o>&gt;&gt;</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>sum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pos</span> <span class=o>-=</span> <span class=n>pos</span> <span class=o>&amp;</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><a href=https://oj.leetcode.com/problems/add-binary/>Add Binary</a> 水题一枚。 调程序一个BUG很不好找：</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>(</span><span class=n>temp</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=sc>&#39;0&#39;</span> <span class=c1>// a = temp &amp; 1 ; b = a + &#39;0&#39;  ;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>temp</span> <span class=o>&amp;</span> <span class=mi>1</span> <span class=o>+</span> <span class=sc>&#39;0&#39;</span>   <span class=c1>// a = 1 + &#39;0&#39;  ; b = temp &amp; 1 ; 
</span></span></span></code></pre></div><ul><li><a href=https://oj.leetcode.com/problems/sort-colors/>Sort Colors</a></li></ul><p>智力题。看下图这种状态，有r,w,b三个指针。[0,r)的都是0，[r,w)都是1, [b,+oo)都是2。 现在考虑w指针所在的数，分三种情况：
(0) w指的数为0,交换w和r所在的数，r和w指针同时右移。
(1) w指的数为1,w右移;
(2) w指的数为2,b左移，交换w和b指针所在的数;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sortColors</span><span class=p>(</span><span class=kt>int</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>w</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span> <span class=n>w</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>;</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>w</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>r</span><span class=o>++</span><span class=p>],</span> <span class=n>A</span><span class=p>[</span><span class=n>w</span><span class=o>++</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>w</span><span class=p>]</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=o>--</span><span class=n>b</span><span class=p>],</span> <span class=n>A</span><span class=p>[</span><span class=n>w</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>w</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p>看到该题<a href=http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem/>背景</a>顿时吓傻</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp># start
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=mo>0001111</span><span class=o>********</span><span class=mi>2222</span>
</span></span><span class=line><span class=cl>   <span class=o>^</span>   <span class=o>^</span>       <span class=o>^</span>
</span></span><span class=line><span class=cl>   <span class=n>r</span>   <span class=n>w</span>       <span class=n>b</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp># case.0
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=mo>00001111</span><span class=o>*******</span><span class=mi>2222</span>
</span></span><span class=line><span class=cl>    <span class=o>^</span>   <span class=o>^</span>      <span class=o>^</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span>   <span class=n>w</span>      <span class=n>b</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp># case.1
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=mo>00011111</span><span class=o>*******</span><span class=mi>2222</span>
</span></span><span class=line><span class=cl>   <span class=o>^</span>    <span class=o>^</span>      <span class=o>^</span>
</span></span><span class=line><span class=cl>   <span class=n>r</span>    <span class=n>w</span>      <span class=n>b</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp># case.2
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=mo>0001111</span><span class=o>*******</span><span class=mi>22222</span>
</span></span><span class=line><span class=cl>   <span class=o>^</span>   <span class=o>^</span>      <span class=o>^</span>
</span></span><span class=line><span class=cl>   <span class=n>r</span>   <span class=n>w</span>      <span class=n>b</span> 
</span></span></code></pre></div><ul><li><a href=https://oj.leetcode.com/problems/first-missing-positive/>First Missing Positive</a>
智力题，找出一个无序序列中第一个缺失的正整数。要求时间O(N)，空间O(1). 其实只要将每个在1～N之前的整数，把i这个数值存放到A[i]这里存放。然后遍历即可。代码如下,复杂度分析：while循环每次swap都会把A[i]这个数放到A[i]-1这个Index对应的位置存放，最多有N个数，所以for循环内所有while进行的swap操作之和不超过N. 摊分下来每个for操作都swap一次。总的复杂度为O(N).</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>firstMissingPositive</span><span class=p>(</span><span class=kt>int</span> <span class=n>A</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=p>;</span> <span class=o>++</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>A</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>			<span class=n>swap</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=p>;</span> <span class=o>++</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/anagrams/>Anagrams</a> anagrams这个单词真是个费解的单词。指的是对应字符个数相等的两个单词，称为anagrams. 例如aaaab和baaaa,aaaba都是anagrams。
每个单词字符排个序，最小字典序唯一。直接hash表判重即可。复杂度O(N<em>M</em>logM), 单词最大长度为M， 共有N个单词。</p></li><li><p><a href=https://oj.leetcode.com/problems/edit-distance/>Edit Distance</a>
求两个字符串的最小编辑距离，从S串到T串，有三种操作： insert; delete; replace. dp[i,j]表示s[1..i]到t[1..j]的最小编辑距离:</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>j</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;=</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>len</span><span class=p>(</span><span class=n>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;=</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>len</span><span class=p>(</span><span class=n>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// delete, insert, replace
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>t</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]);</span> 
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/trapping-rain-water/>Trapping Rain Water</a>智力题。关键考虑每个i对答案的贡献值求和。能用一次遍历并且用O(1)的空间计算出答案吗？ 这里还有个<a href=http://qandwhat.apps.runkite.com/i-failed-a-twitter-interview/>悲剧的故事</a></p></li><li><p><a href=https://oj.leetcode.com/problems/set-matrix-zeroes/>Set Matrix Zeroes </a>matrix[0,i]和matrix[i,0]保存maxtrix[i,j]的0状态,另设两个遍历row,col记录matrix[0,0..n-1]和matrix[0..n-1,0]是否为0.即可。</p></li><li><p><a href=https://oj.leetcode.com/problems/median-of-two-sorted-arrays/>Median of Two Sorted Arrays</a>两个有序序列A[0..M-1]和B[0..N-1]找第k小的数问题。假设A[k/2-1]&lt;B[k/2-1]，那么A[k/2-1]排在合并序列中的序号小于K。那么搜索第K值的时候，可以丢弃掉<code>A[k/2-1]</code>之前（包括自己）的一段。题目找的是第<code>（m+n)/2</code>小，每次减少一半的规模，所以总复杂都<code>log(m+n)</code>.</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>double</span> <span class=nf>findKth</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>//always assume that m is equal or smaller than n
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>m</span> <span class=o>&gt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>findKth</span><span class=p>(</span><span class=n>b</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>m</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>b</span><span class=p>[</span><span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>min</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//divide k into two parts
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>pa</span> <span class=o>=</span> <span class=n>min</span><span class=p>(</span><span class=n>k</span> <span class=o>/</span> <span class=mi>2</span><span class=p>,</span> <span class=n>m</span><span class=p>),</span> <span class=n>pb</span> <span class=o>=</span> <span class=n>k</span> <span class=o>-</span> <span class=n>pa</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>pa</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>[</span><span class=n>pb</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>findKth</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>pa</span><span class=p>,</span> <span class=n>m</span> <span class=o>-</span> <span class=n>pa</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>k</span> <span class=o>-</span> <span class=n>pa</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>pa</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>[</span><span class=n>pb</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>findKth</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>b</span> <span class=o>+</span> <span class=n>pb</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=n>pb</span><span class=p>,</span> <span class=n>k</span> <span class=o>-</span> <span class=n>pb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>a</span><span class=p>[</span><span class=n>pa</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><p><a href=https://oj.leetcode.com/problems/longest-palindromic-substring/>Longest Palindromic Substring</a> <a href=http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html>Manacher’s Algorithm</a>算法。能在O(N)的复杂度内找到一个字符串的最长回文子串。假设用动态规划或者暴力，复杂度都为O(N^2). 后缀数组也能解决这个问题。</p></li><li><p><a href=https://oj.leetcode.com/problems/regular-expression-matching/>Regular Expression Matching </a>没找到什么线性算法。 暴力算法来源于leetcode，假设<code>s=abbbbbbbbbbbbbbbbbb</code>, <code>t=ab*cd</code>这样的话。可能会出现如下情况：当有一个<code>*</code>字符时，最坏的情况下会达到O（n*m),这还的用KMP算法去做字串匹配. 当多个 <code>\*</code>字符时，就是<code>\*</code>的指数级复杂度了。</p></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>abbbbbbbbbbbbbbbbbb</span>
</span></span><span class=line><span class=cl>     <span class=o>^</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>acd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>abbbbbbbbbbbbbbbbbb</span>
</span></span><span class=line><span class=cl>      <span class=o>^</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>a</span> <span class=n>cd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>abbbbbbbbbbbbbbbbbb</span>
</span></span><span class=line><span class=cl>       <span class=o>^</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>a</span>  <span class=n>cd</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=n>abbbbbbbbbbbbbbbbbb</span>
</span></span><span class=line><span class=cl>        <span class=o>^</span>
</span></span><span class=line><span class=cl><span class=n>t</span> <span class=o>=</span> <span class=n>a</span>   <span class=n>cd</span>
</span></span></code></pre></div><ul><li><a href=https://oj.leetcode.com/problems/scramble-string/>Scramble String </a>DFS 类似卡特兰解空间搜索加上减枝，减枝技巧包括： 两串长度相等； 两串无序hash值相等; 两串同类字符数必须相等。
复杂度分析：</li></ul><pre tabindex=0><code>h[n] = 2 * sum( h[i] * h[n-i] ) (1&lt;= i &lt; n )
</code></pre><ul><li><a href=https://oj.leetcode.com/problems/recover-binary-search-tree/>Recover Binary Search Tree</a></li></ul><p>假设一个序列 , 其中 8 和 14 被误交换了。 如图， 导致序列会有两个<code>></code> , 记录第1个<code>></code>的前驱和第2个<code>></code>的后继两个指针，交换即可.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp># noraml
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=o>&lt;</span> <span class=o>&lt;</span> <span class=o>&lt;</span>  <span class=o>&lt;</span>  <span class=o>&lt;</span>  <span class=o>&lt;</span>
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=mi>5</span> <span class=mi>8</span> <span class=mi>10</span> <span class=mi>11</span> <span class=mi>14</span> <span class=mi>23</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp># missing swap
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=o>&lt;</span> <span class=o>&lt;</span>  <span class=o>&gt;</span>  <span class=o>&lt;</span>  <span class=o>&gt;</span> <span class=o>&lt;</span> 
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=mi>5</span> <span class=mi>14</span> <span class=mi>10</span> <span class=mi>11</span> <span class=mi>8</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl>    <span class=o>^</span>        <span class=o>^</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp># after
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=o>&lt;</span> <span class=o>&lt;</span>  <span class=o>&gt;</span>  <span class=o>&lt;</span>  <span class=o>&gt;</span> <span class=o>&lt;</span> 
</span></span><span class=line><span class=cl><span class=mi>1</span> <span class=mi>5</span> <span class=mi>8</span> <span class=mi>10</span> <span class=mi>11</span> <span class=mi>14</span> <span class=mi>23</span>
</span></span><span class=line><span class=cl>    <span class=o>^</span>        <span class=o>^</span>
</span></span></code></pre></div><ul><li><a href=https://oj.leetcode.com/problems/minimum-window-substring/>Minimum Window Substring</a> 字符串滑动窗口， 维护4个变量： left 左端点 ； right 右端点 ; cur[256] 各字符当前窗口内的计数值； curlen 当前窗口内目标串字符的个数。 时间复杂度O(N). 类似的题： <a href=https://oj.leetcode.com/problems/substring-with-concatenation-of-all-words/>Substring with Concatenation of All Words </a>, <a href=https://oj.leetcode.com/problems/longest-substring-without-repeating-characters/>Longest Substring Without Repeating Characters </a>.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://openinx.github.io/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://openinx.github.io/posts/2014-08-17-leveldb-compaction/><span class=title>« Prev</span><br><span>LevelDB Compaction原理</span>
</a><a class=next href=https://openinx.github.io/posts/2014-06-07-learning-from-kazoo/><span class=title>Next »</span><br><span>Zookeeper的客户端Kazoo</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://openinx.github.io/>Openinx Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>